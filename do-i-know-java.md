---
description: 우리나라에 스프링으로 개발하는 방식이 관행으로 자리잡은 것이 궁금한 1인
---

# Do I Know Java?

### 자바 프로그래밍 언어 플랫폼

자바 프로그래밍 언어에는 아래 4가지 플랫폼이 존재하며, 모든 자바 플랫폼들은 JVM 과 API 로 구성되어 있다.

#### Java SE

* 대부분의 사람들이 떠올리는 플랫폼
* 타입/네트워킹/보안/DB/GUI/XML 등 고수준의 클래스의 집합
* 주요 패키지 java.lang.\*, java.io.\*, java.util.\*, java.awt.\* 등

#### Java EE \( Java Enterprise Edition \)

* Java SE + 네트워크 어플리케이션 개발, 실행을 위한 API 환경 제공
* JSP/Servlet, JDBC, JNDI, EJB 등 기술 탑재

이외에도 Java ME, Java FX 가 존재하지만, 해당 플랫폼은 구글링을 통해 알아보도록 한다.

### Java EE

Java를 통해 웹 애플리케이션을 개발한다는 것은 JSP/Servlet 기술을 사용하여 개발한다는 것이다.  
Servlet 은 자바 기반의 CGI 프로그램이며, 서블릿 컨테이너에 의해 관리된다.

#### CGI

* CGI는 서버와 프로그램이 주고 받는 데이터에 대한 인터페이스를 정의한 것이고, 사용자의 동적 데이터 요구에 따라 탄생하게 된 개념임. 최초의 웹은 정적 데이터만 주고 받을 수 있었음.
* 최초 CGI 는 요청 당 프로세스가 생성됐지만, 비효율성으로 인해 스레드 단위 동작으로 고안한 Servlet 이 탄생하게 됨.

#### 서블릿 컨테이너

* 서블릿 컨테이너는 서블릿의 생성/실행/소멸을 관리하며, 서블릿 대신 웹서버와 데이터를 주고 받는다. 서블릿 컨테이너를 구현한 서버는 대표적으로 Tomcat, Jetty 가 존재함.
* 서블릿 컨테이너로 관리하는 이유는 웹서버와 애플리케이션간 서로 다른 체계를 갖고 있기 때문에, 데이터 교환이 어려운 것이 문제였음.

  
Java 에서 WAS 는 Java EE 기술 사양을 준수해서 만든 서버를 가리키며, Java EE 의 구현체라고도 한다.   
\(JEUS, WebLogic, JBoss 등이 있다\) = EJB Container 라고 한다. \(EJB에 대한 설명은 아래 참조\)  
EJB Container 는 EJB 서버와 Enterprise Bean 사이에 통신을 하게 해주는 역할  


즉, EJB 서버는 데이터베이스 및 트랜잭션 처리등을 구현하고 EJB Container 를 관리한다. EJB 구조를 사용하면 이와 연결되는 클라이언트 애플리케이션은 Java Application / JSP 등이 있다.

### EJB

Java EE 의 API 중 하나인 EJB\(Enterprise Java Bean\) 가 존재한다. 이는 자바 객체를 재사용 가능하게끔 컴포넌트화 시킨 것을 의미한다. 단순히 얘기하면 Enterprise 는 기업을 의미하고 기업 환경에서 개발을 단순화하기 위해 썬마이크로시스템즈가 만든 스펙이며, 기업환경에서 개발을 한다는 것은 대규모 시스템 구축을 위한 작업임을 의미한다.

#### JavaBean

EJB를 알려면 JavaBean 의 개념을 알아야 한다. JavaBean 은 자바로 작성된 소프트웨어 컴포넌트\(클래스\)를 의미하며, JavaBeans 는 여러 클래스가 복합적으로 이루어진 구조를 말한다. 이는 클라이언트와 통신을 목적으로 하는 객체이다. 기본적으로 재사용이 가능하고 JSP 파일 내에서 사용이 가능한 객체이다. 재사용이 목적이기 때문에 당연히 여러 JSP 페이지에서 사용할 수 있다.  
\(예를 들면, class Member 와 같이 일반적으로 Data Transfer Object 를 말하는 것으로 이해함\)

JavaBean 이 클라이언트와의 통신에 사용하는 것이라면, EJB는 서버에서 동작하는 JavaBean 을 의미함.

#### 장단점

개발자들이 단순히 비즈니스 로직만 만들면 편하고 좋겠지만, DB 및 트랜잭션 처리와 같은 처리 때문에 어려움이 존재했음. 보통 EJB 는 비즈니스 로직을 담고 있으며, 객체 간 의존성을 해결하기 위해 등장한 기술. 그러나, 비즈니스 로직이 담긴 컴포넌트가 재사용 될 수 있게 설계하는 것은 쉽지 않다.. 요구사항에 의해서 조금씩 비즈니스 로직의 기능이 상이해지기 때문임. 이러한 비즈니스 로직이 작성될 때 마다 EJB의 인터페이스를 따르기 위해서 여러 클래스를 상속 받았고 특정 기술\(EJB\) 에 종속되는 문제점이 발생했다.

이럼에도 장점은 대량의 트랜잭션 처리를 도와주고 서로 다른 도메인에 대해 분산 트랜잭션을 지원한다. 이런 복잡한 기능을 직접 구현하지 않아도 된다는 것이 큰 장점임.. 이외에도 단시간 급격한 요청에 대비하여 객체를 미리 생성하는 인스턴스 풀링을 지원함.

하지만 분산환경 지원을 위한 객체 직렬화 때문에 실행속도가 느리고 복잡한 프로그래밍 모델을 갖고 있음. 특정한 환경이나 기술에 코드가 종속적이고 테스트가 어려운 것이 단점.  
\(Java RMI 기술을 말하는 것 같은데..\)

글로 백날 써봐야 위의 내용을 이해하기는 쉽지 않을 것 같다는게 결론. 학부생 시절에 JBoss + Java RMI 을 통해 원격지에 있는 비즈니스 로직을 호출해야하는 요구사항이 있어서 구현한적이 있었다. 그게 EJB 였다니.. 그리고 JBoss 를 구동 시킨 후에 새로운 프로젝트를 생성하고 클라이언트 애플리케이션인 JSP 파일을 작성했음. 거기에 원격지에 구현된 EJB를 import 하고 메서드를 호출했던 기억이 있음. RMI 는 EJB의 아주 일부 기능 일 수 있겠지만.. 번외로 Microsoft 사의 WCF 기술이 Java RMI 와 유사한 기능을 하는 것으로 알고 있음. 기억의 단편이긴 하지만 비트교육센터 윈도우개발자 과정 당시에 썼던 기억이 있음.

### Spring

개발자는 비즈니스 로직에만 집중할 수 있도록 EJB 를 사용하지 않고 의존성 해결이 가능한 컨테이너를 개발하고자 한 것이 시작.

POJO\(단순한 자바 클래스\)를 사용하여 EJB의 기능을 유지하되 복잡성은 제거하게 됨.

#### Spring Container

인스턴스의 생성 주기 관리, 요청/응답 객체 생성하여 적절한 서블릿을 호출해 바이패스 처리함. 서블릿 라이프 사이클 관장. 어플리케이션에 필요한 객체 생성 및 의존관계 관리

#### Spring Bean Factory

Bean 객체를 생성 및 관리하는 기능 제공하며, 클라이언트가 요청할 때만 Bean 생성하며, 이를 확장한 개념이 ApplicationContext 임.

#### IoC

종속성을 주입\(Dependency Injection\) 하는 행위로 Spring Container 가 Bean 을 만들 때, 종속되는 위치나 인스턴스 제어를 위해 주입을 결정하게 됨. 개발자가 결정하는 것이 아닌 프로그램이 결정하기 때문에 이를 제어의 역전이라고 한다.

#### ApplicationContext

모든 유형의 객체를 관리하며, Spring IoC 컨테이너를 이해하는데 핵심 요소. configuration metadata 에 Bean 생성의 정의가 있으며, ApplicationContext 가 이를 제어할 수 있음. 가령 아래와 같이 표현할 수 있다. \(Java Reflection 개념\)

```java
ApplicationContext context = new ClassPathXmlApplicationContext("service.xml", "foo.xml");

/* Reflection */
MemberService service = context.getBean("member", MemberService.class);

service.printMemberList();
```

#### Bean

Spring IOC 컨테이너에 의해 인스턴스화 되고 조립/관리되는 객체

#### configuration metadata

컨테이너에 지시할 사항이 나열되어 있고 기본적으로 XML 을 사용한다. Spring 3.0 이후부터는 @Configuration 을 사용한 클래스의 @Bean 으로도 나타낸다.

#### Annotation-based  vs  XML

각 방법에 장단점이 있기 때문에 결정은 개발자의 몫이다. Annotation-based 인 경우 짧고 간결한 설정을 할 수 있지만, XML 로 정의하는 경우 소스코드의 수정이나 컴파일이 필요 없는 것이 장점. 일부 개발자는 Annotation 이 선언된 클래스는 더이상 POJO 가 아니라고 주장한다. 설정의 분산이 제어하기 어렵다고 판단한 모양인듯..

### 우리나라에서 웹개발의 역사

우리나라에서는 기업형 서버 소프트웨어 개발이라는 것이 성행했다. C/C++ 을 이용해서 다양한 회사의 미들웨어 제품들을 사용해서 개발하는 방식 이었기 때문에, 소프트웨어가 특정 회사에 종속될 수 밖에 없었음.

이에 Java의 플랫폼 독립성을 이용해서 미들웨어에 필요한 공통 API 를 제공하면 특정 회사에 종속되는 문제를 해결할 수 있을 것이라 생각했고, 서버 개발에만 필요한 기능을 긁어모아서 만든 것이 Java EE 임. 이것이 WAS 라고 불리는 Java EE 어플리케이션 서버의 시작이었음.

Java EE 가 각광을 받으면서 여러 벤더 사 들이 Java EE 의 스펙을 구현한 어플리케이션 서버 제품을 출시했음. 당시 유행하던 PHP/ASP 와 함께 CGI 를 걷어내고 Java 언어가 인기를 얻는데 큰 공헌을 함.

Java EE 의 핵심은 EJB 라는 API 이었는데, JSP 처럼 GUI 를 표현하는데 사용하는 것이 아닌, Model 의 개념으로 비즈니스 로직을 담당하는 분산처리/트랜잭션/보안 등을 표현하는데 사용했음.

이러한 EJB의 특성 덕분에 널리 쓰이게 됐지만, 자바의 특성에 맞는 설계를 하면서 문제가 발생했음. 기본적인 정렬 기능이나 이외의 기본 기능들을 Java EE 를 판매하는 회사들이 각각 독립적으로 커스터마이징 할 수 밖에 없는 문제가 발생함.

이에 따라, 각 벤더 사가 만든 Java EE 서버에 애플리케이션이 종속되는 문제가 생겼고 당시엔 기본 값\(Default Value\) 에 대한 정의 자체가 없었기 때문에, Java EE 서버에 산출물 배포를 위해서 엄청난 양의 XML 설정 코드를 집어넣어야 했음. \(소위 말해서 XML 지옥이라고 함\)

이러한 문제점 개선을 위해 Spring Framework 가 처음 개발됐고, Java EE 를 구현한 비싼 WAS 솔루션을 쓰지 않더라도 Tomcat 과 같은 서블릿 컨테이너에서도 구동이 되는 것이 큰 장점으로 작용함.

Tomcat 자체가 원래는 실제 서비스의 용도보다는 Servlet/JSP 기술에 대한 설명을 하기 위한 용도로 개발되었지만, 현재는 실무에서도 사용할 수 있을만큼 안정성이 확보되었음. \(Tomcat 자체가 이전에는 안전성이 매우 떨어진다는 편견이 있었음\)

Spring 이 존재함으로써, 비싼 Java EE 서버를 구매할 필요도 없었고 EJB 가 제공하던 모든 기능을 쓸 수 있을뿐더러 더이상 굳이 Java EE 를 공부 할 필요가 없게 되었음.

\[참조\] [https://okky.kr/article/415474](https://okky.kr/article/415474)

